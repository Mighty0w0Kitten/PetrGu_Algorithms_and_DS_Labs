def lines(a):
    # Берём первый элемент массива как начальное значение суммы
    current_sum = a[0]   # сумма текущей подпоследовательности
    max_sum = a[0]       # максимальная сумма, найденная на данный момент

    # Начальные индексы:
    start = 0            # индекс начала подпоследовательности с максимальной суммой
    end = 0              # индекс конца подпоследовательности с максимальной суммой
    temp_start = 0       # временный индекс начала текущей подпоследовательности

    # Перебираем элементы массива начиная со второго (индекс 1)
    for i in range(1, len(a)):
        x = a[i]    # текущий элемент массива

        # Проверяем, что лучше:
        # 1) начать новую подпоследовательность с текущего элемента x или продолжить существующую, добавив x к current_sum
        if x > current_sum + x:
            # Если новый элемент сам по себе больше, значит предыдущая подпоследовательность нам невыгодна.
            current_sum = x
            temp_start = i  # запоминаем новый возможный старт
        else:
            # Иначе добавляем элемент к текущей сумме
            current_sum += x

        # Если найденная текущая сумма больше глобального максимума, обновляем лучший результат и запоминаем индексы.
        if current_sum > max_sum:
            max_sum = current_sum
            start = temp_start
            end = i

    # Возвращаем найденную сумму и границы подпоследовательности
    return max_sum, start, end

# Первая строка — количество элементов последовательности
n = int(input())
# Вторая строка — сама последовательность, превращаем в список чисел
a = list(map(int, input().split()))

# Вычисление результата
s, l, r = lines(a)

print(s)
print(l+1, r+1)